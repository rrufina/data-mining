# -*- coding: utf-8 -*-
"""spectrum_new.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1ftiyiZF5dc-jblGBtVdayZ-zISr5vv6L
"""

import pandas as pd
import time, threading
import numpy as np

# 0 - Revoke, 1 - Post, 2 - Match

# from google.colab import drive
# drive.mount('/content/drive')

'''
# CHANGE THIS
WORKING_DIR = r"D:\Data\MOEX-FX\2018-03\\"
OrderLog = "OrderLog20180302"
TradeLog = "TradeLog20180302"
order_log = pd.read_csv(WORKING_DIR + OrderLog + ".txt")
trade_log = pd.read_csv(WORKING_DIR + TradeLog + ".txt")
'''
OrderLog = "OrderLog20180302"
import gzip

with gzip.open('/content/drive/MyDrive/DataMining/2018-03/OrderLog20180301.txt.gz', 'rb') as f:
    order_log = pd.read_csv(f)

with gzip.open('/content/drive/MyDrive/DataMining/2018-03/TradeLog20180301.txt.gz', 'rb') as f:
    trade_log = pd.read_csv(f)

class Action():
    REVOKE = 0
    POST = 1
    MATCH = 2


CODES = ['USD000000TOD', 'USD000UTSTOM', 'EUR_RUB__TOD', 'EUR_RUB__TOM', 'EURUSD000TOD', 'EURUSD000TOM', ]

instruments_info = {'USD000000TOD': {'SCHEDULE': 174500000000, 'PRICE_STEP': 0.0025, 'INDEX': 0},
                    'USD000UTSTOM': {'SCHEDULE': 235000000000, 'PRICE_STEP': 0.0025, 'INDEX': 1},
                    'EUR_RUB__TOD': {'SCHEDULE': 150000000000, 'PRICE_STEP': 0.0025, 'INDEX': 2},
                    'EUR_RUB__TOM': {'SCHEDULE': 235000000000, 'PRICE_STEP': 0.0025, 'INDEX': 3},
                    'EURUSD000TOM': {'SCHEDULE': 235000000000, 'PRICE_STEP': 0.00001, 'INDEX': 4},
                    'EURUSD000TOD': {'SCHEDULE': 150000000000, 'PRICE_STEP': 0.00001, 'INDEX': 5}}

# filtering orders
df_order = order_log[(order_log['SECCODE'].isin(CODES)) & (order_log['TIME'] < 235000000000)].copy()[:1000]

# df_order = order_log[(order_log['SECCODE'].isin(CODES)) & (order_log['TIME'] < 100000210798)].copy()[:10000]
df_trade = trade_log[trade_log['SECCODE'].isin(CODES)].copy()

# harvard professor wrote this +100000 IQ code
prep_dic = {Action.POST: 0, Action.MATCH: 1, Action.REVOKE: 2}
unprep_dic = {0: Action.POST, 1: Action.MATCH, 2: Action.REVOKE}

df_order['ACTION'] = df_order['ACTION'].apply(lambda num: prep_dic[num])
df_order.sort_values(by=['TIME', 'ACTION'], inplace=True)
df_order['ACTION'] = df_order['ACTION'].apply(lambda num: unprep_dic[num])

df_order.head()

df_order[df_order['NO'] == 100]

df_order.info()

df_trade.head()

df_trade.info()

df_order['TRADENO'].value_counts()

total_mistakes = 0


def print_error(error):
    global total_mistakes
    print('-' * 40)
    print(f'in row: {row["NO"]}')
    print(error)
    print('-' * 40)
    print()
    total_mistakes += 1


def check_exists(df_cur, row, NO='ORDERNO'):
    # check if the given ORDERNO exists

    # sub_df = df_cur[df_cur[NO] == row[NO]]
    df_cur_searchable = df_cur.set_index[NO]
    sub_df = df_cur[df_cur_searchable.index.isin(row[NO])]
    if len(sub_df) > 0:
        return True, sub_df
    # printing the error
    else:
        print_error(f"ERROR: Record with {NO} {row[NO]} doesn't exist")
        return False, None


def handle_revoke(df_cur, row):
    # check if the given ORDERNO exists
    check, sub_df = check_exists(df_cur, row)
    df_cur_searchable = df_cur.set_index['ORDERNO']
    if check:
        series = sub_df.iloc[0]
        # check if revoking volume is not greater than the current one
        if series['VOLUME'] >= row['VOLUME']:
            if series['VOLUME'] == row['VOLUME']:
                # removing the record
                # df_cur.drop(df_cur[df_cur['ORDERNO'] == row['ORDERNO']].index, inplace=True)
                df_cur.drop(df_cur_searchable.index.isin(row['ORDERNO']).index, inplace=True)
            else:
                # reducing the amount
                # df_cur.loc[df_cur[df_cur['ORDERNO'] == row['ORDERNO']].index, ['VOLUME']] = series['VOLUME'] - row['VOLUME']
                df_cur.iat[df_cur_searchable.index.isin(row['ORDERNO']).index, 'VOLUME'] = series['VOLUME'] - row['VOLUME']

        # printing the error
        else:
            # TODO: DISCRUSS WITH THE TEAM
            # df_cur.loc[df[df_cur['ORDERNO'] == row['ORDERNO']].index, ['VOLUME']] = series['VOLUME'] - row['VOLUME'] # negative number
            # decided to delete
            # df_cur.drop(df_cur[df_cur['ORDERNO'] == row['ORDERNO']].index, inplace=True)
            df_cur.drop(df_cur_searchable.index.isin(row['ORDERNO']).index, inplace=True)
            print_error("ERROR: Cannot revoke more that there is")


def handle_match(df_cur, row):
    global df_trade
    # check if the given ORDERNO exists
    check, sub_df = check_exists(df_cur, row)
    df_cur_searchable = df_cur.set_index['ORDERNO']
    if check:
        series = sub_df.iloc[0]
        # check if the given tradeno exists in trade logs
        check, sub_trade = check_exists(df_trade, row, 'TRADENO')
        if check:
            series_trade = sub_trade.iloc[0]

            # seller = df_cur[df_cur['ORDERNO'] == series_trade['SELLORDERNO']]
            seller = df_cur[df_cur_searchable.index.isin(series_trade['SELLORDERNO'])]
            # buyer = df_cur[df_cur['ORDERNO'] == series_trade['BUYORDERNO']]
            buyer = df_cur[df_cur_searchable.index.isin(series_trade['BUYORDERNO'])]

            # check if seller and buyer exist
            if len(seller) > 0 and len(buyer) > 0:
                seller = seller.iloc[0]
                buyer = buyer.iloc[0]

                # check if the volume is ok
                if seller['VOLUME'] >= row['VOLUME'] and buyer['VOLUME'] >= row['VOLUME']:
                    if seller['VOLUME'] == row['VOLUME']:
                        # removing the record
                        # df_cur.drop(df_cur[df_cur['ORDERNO'] == seller['ORDERNO']].index, inplace=True)
                        df_cur.drop(df_cur_searchable.index.isin(seller['ORDERNO']).index, inplace=True)
                    else:
                        # reducing the amount
                        # df_cur.loc[df_cur['ORDERNO'] == seller['ORDERNO'], ['VOLUME']] = seller['VOLUME'] - row['VOLUME']
                        df_cur.iat[df_cur_searchable.index.isin(seller['ORDERNO']).index, 'VOLUME'] = seller['VOLUME'] - row['VOLUME']

                    if buyer['VOLUME'] == row['VOLUME']:
                        # removing the record
                        # df_cur.drop(df_cur[df_cur['ORDERNO'] == buyer['ORDERNO']].index, inplace=True)
                        df_cur.drop(df_cur_searchable.index.isin(buyer['ORDERNO']).index, inplace=True)
                    else:
                        # reducing the amount
                        # df_cur.loc[df_cur['ORDERNO'] == buyer['ORDERNO'], ['VOLUME']] = buyer['VOLUME'] - row['VOLUME']
                        df_cur.iat[df_cur_searchable.index.isin(buyer['ORDERNO']).index, 'VOLUME'] = seller['VOLUME'] - row['VOLUME']
                # printing the error
                else:
                    # TODO: Discuss with the team
                    # negative numbers
                    if seller['VOLUME'] < row['VOLUME']:
                        # df_cur.drop(df_cur[df_cur['ORDERNO'] == seller['ORDERNO']].index, inplace=True)
                        df_cur.drop(df_cur_searchable.index.isin(seller['ORDERNO']).index, inplace=True)
                    else:
                        # df_cur.loc[df_cur['ORDERNO'] == seller['ORDERNO'], ['VOLUME']] = seller['VOLUME'] - row['VOLUME']
                        df_cur.iat[df_cur_searchable.index.isin(seller['ORDERNO']).index, 'VOLUME'] = seller['VOLUME'] - row['VOLUME']
                    if buyer['VOLUME'] < row['VOLUME']:
                        # df_cur.drop(df_cur[df_cur['ORDERNO'] == buyer['ORDERNO']].index, inplace=True)
                        df_cur.drop(df_cur_searchable.index.isin(buyer['ORDERNO']).index, inplace=True)
                    else:
                        # df_cur.loc[df_cur['ORDERNO'] == buyer['ORDERNO'], ['VOLUME']] = buyer['VOLUME'] - row['VOLUME']
                        df_cur.iat[df_cur_searchable.index.isin(buyer['ORDERNO']).index, 'VOLUME'] = seller['VOLUME'] - row['VOLUME']
                    print_error("ERROR: Not enough amount for buying and/or selling")

            # printing the error
            else:
                print_error(f"ERROR: There's no such buyer and/or seller")


df_order[df_order['PRICE'] == 0]


# ГОВНОКОД NO.1
# блин хз возможно класс больше не нужен

class Spectrum():
    def __init__(self, seccode):
        self.seccode = seccode
        self.best_ask = 100000000
        self.best_bid = -1
        self.bids = [0] * 10
        self.asks = [0] * 10

# Helper functions
import math


def get_distance(dif, step):
    return math.floor(dif / (step * 5))


# ГОВНОКОД NO.2

spectrums = dict()
for i in instruments_info.keys():
    spectrums[i] = Spectrum(i)

# ГОВНОКОД NO.3

import math


def change_spectrums(df_cur, row):  # seccode = row['SECCODE']
    seccode = row['SECCODE']
    step = instruments_info[seccode]['PRICE_STEP']
    # if row['BUYSELL'] == 'B':
    #  if spectrums[instruments_info[seccode]['INDEX']].best_bid < row['PRICE']:
    spectrum = spectrums[seccode]

    new_price = row['PRICE']

    if row['ACTION'] == Action.POST:

        if row['BUYSELL'] == 'B':
            if new_price > spectrum.best_bid:
                # temp_b = df_cur.loc[(df_cur['SECCODE'] == seccode) & (df_cur['BUYSELL'] == 'B')]
                temp_b = df_cur[(df_cur['SECCODE'] == seccode) & (df_cur['BUYSELL'] == 'B')]

                spectrum.best_bid = new_price
                new_bids = [0] * 10
                for index, row in temp_b.iterrows():
                    price = row['PRICE']
                    dif = spectrum.best_bid - price
                    if dif > step * 49:
                        pass
                    else:
                        new_bids[9 - math.floor(dif / (step * 5))] += row['VOLUME']
                spectrum.bids = new_bids
            elif new_price == spectrum.best_bid:
                # new_bids = spectrum.bids
                # new_bids[9] += row['VOLUME']
                # spectrum.bids = new_bids
                spectrum.bids[9] += row['VOLUME']
            else:
                dif = spectrum.best_bid - new_price
                if dif > step * 49:
                    pass
                else:
                    spectrum.bids[9 - math.floor(dif / (step * 5))] += row['VOLUME']

        if row['BUYSELL'] == 'S':
            if new_price < spectrum.best_ask:
                # temp_s = df_cur.loc[(df_cur['SECCODE'] == seccode) & (df_cur['BUYSELL'] == 'S')]
                temp_s = df_cur[(df_cur['SECCODE'] == seccode) & (df_cur['BUYSELL'] == 'S')]

                spectrum.best_ask = new_price
                new_asks = [0] * 10
                for index, row in temp_s.iterrows():
                    price = row['PRICE']
                    dif = price - spectrum.best_ask
                    if dif > step * 49:
                        pass
                    else:
                        new_asks[math.floor(dif / (step * 5))] += row['VOLUME']
                spectrum.asks = new_asks
            elif new_price == spectrum.best_ask:
                # new_asks = spectrum.asks
                # new_asks[0] += row['VOLUME']
                # spectrum.asks = new_asks
                spectrum.asks[0] += row['VOLUME']
            else:
                dif = new_price - spectrum.best_ask
                if dif > step * 49:
                    pass
                else:
                    spectrum.asks[math.floor(dif / (step * 5))] += row['VOLUME']
    # проверить если прайс = бест
    # elif row['ACTION'] == Action.REVOKE:
    else:
        if row['BUYSELL'] == 'B':

            if new_price == spectrum.best_bid:
                if row['VOLUME'] >= spectrum.bids[9]:
                    # temp_b = df_cur.loc[(df_cur['SECCODE'] == seccode) & (df_cur['BUYSELL'] == 'B')]
                    temp_b = df_cur[(df_cur['SECCODE'] == seccode) & (df_cur['BUYSELL'] == 'B')]
                    spectrum.best_bid = temp_b['PRICE'].max()
                    new_bids = [0] * 10
                    for index, row in temp_b.iterrows():
                        price = row['PRICE']
                        dif = spectrum.best_bid - price
                        if dif > step * 49:
                            pass
                        else:
                            new_bids[9 - math.floor(dif / (step * 5))] += row['VOLUME']
                    spectrum.bids = new_bids
                else:
                    spectrum.bids[9] -= row['VOLUME']

            elif new_price > spectrum.best_bid:
                pass
            else:
                dif = spectrum.best_bid - new_price
                if dif > step * 49:
                    pass
                else:
                    # new_bids = spectrum.bids
                    # new_bids[9-math.floor(dif/(step*5))] -= row['VOLUME']
                    # spectrum.bids = new_bids
                    spectrum.bids[9 - math.floor(dif / (step * 5))] -= row['VOLUME']
                    if spectrum.bids[9 - math.floor(dif / (step * 5))] < 0:
                        spectrum.bids[9 - math.floor(dif / (step * 5))] = 0

        if row['BUYSELL'] == 'S':

            if new_price == spectrum.best_ask:
                if row['VOLUME'] >= spectrum.asks[0]:
                    # temp_s = df_cur.loc[(df_cur['SECCODE'] == seccode) & (df_cur['BUYSELL'] == 'S')]
                    temp_s = df_cur[(df_cur['SECCODE'] == seccode) & (df_cur['BUYSELL'] == 'S')]

                    spectrum.best_ask = temp_s['PRICE'].min()
                    new_asks = [0] * 10

                    for index, row in temp_s.iterrows():
                        price = row['PRICE']
                        dif = price - spectrum.best_ask
                        if dif > step * 49:
                            pass
                        else:
                            new_asks[math.floor(dif / (step * 5))] += row['VOLUME']
                    spectrum.asks = new_asks
                else:
                    spectrum.asks[0] -= row['VOLUME']

            elif new_price < spectrum.best_ask:
                pass
            else:
                dif = new_price - spectrum.best_ask
                if dif > step * 49:
                    pass
                else:
                    # new_asks = spectrum.asks
                    # new_asks[math.floor(dif/(step*5))] -= row['VOLUME']
                    # spectrum.asks = new_asks
                    spectrum.asks[math.floor(dif / (step * 5))] -= row['VOLUME']
                    if spectrum.asks[math.floor(dif / (step * 5))] < 0:
                        spectrum.asks[math.floor(dif / (step * 5))] = 0

    b = spectrum.bids.copy()
    b.extend(spectrum.asks)
    # print(spectrum.bids)
    # print(spectrum.asks)
    return b


start = time.time()
k = 0
# empty df for keeping track
df_cur = pd.DataFrame(columns=df_order.columns)
df_spec = pd.DataFrame(columns=['SECCODE', 'TIMESTAMP', 'BID_ASK'])

# for processing each TRADENO only once
matches = []

# iterating through the order book
# TODO: i guess this loop can be improved, i dont know how yet
for index, row in df_order.iterrows():
    # if post -> add to df_cur
    if row['ACTION'] == Action.POST:
        df_cur = df_cur.append(row)


    elif row['ACTION'] == Action.REVOKE:
        handle_revoke(df_cur, row)


    elif row['ACTION'] == Action.MATCH:
        if row['TRADENO'] in matches:
            matches.remove(row['TRADENO'])
            continue
        else:
            matches.append(row['TRADENO'])
            handle_match(df_cur, row)

    # для каждой новой row считаем спектрум и добавляем в файлик
    values = change_spectrums(df_cur, row)
    d = {'SECCODE': row['SECCODE'], 'TIMESTAMP': row['TIME'], 'BID_ASK': values}
    df_spec = df_spec.append(d, ignore_index=True)
    # print(values)
    k += 1
    if k % 50000 == 0:
        df_spec.to_csv('/content/drive/MyDrive/DataMining/spectrums/' + str(k // 50000) + '.csv')

df_cur.to_csv('no-thread-lol.csv')
df_spec.to_csv('spectru.csv')

end = time.time()

print(end - start)

df_spec.to_csv('/content/drive/MyDrive/DataMining/spectrum.csv')

df_spec

final = df_cur.groupby(['SECCODE', 'BUYSELL', 'PRICE'])['VOLUME'].sum().reset_index() \
    .sort_values(by=['SECCODE', 'BUYSELL', 'PRICE'])

final

final.to_csv('OrderBook' + OrderLog[8:] + '.csv')
